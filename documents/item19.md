# 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

## Part 1. 안전하고 효율적인 상속 방법

### 1. 상속이란?
이 책에서의 상속은 `구현 상속`을 말한다.(아이템 18 참고)  
클래스가 다른 클래스를 확장하는 상속을 뜻한다. 인터페이스 상속이 아니다.

### 2. 설계 및 문서화 대상
* 설계 및 문서화 대상 : 상속용 클래스
* 재정의 가능의 정의 : public과 protected 메서드 중 final이 아닌 모든 메서드

### 3. 상속을 고려한 설계 및 문서화 방법
재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.(`@implSpec` 태그 사용)
>[1] API로 공개된 메서드에서 자신의 또 다른 재정의 가능 메서드를 호출할 경우, 그 사실을 적시해야 한다.  
[2] 어떤 순서로 호출하는지 설명해야 한다.  
[3] 호출 결과가 이어지는 처리에 어떤 영향을 주는지 담아야 한다.  
[4] 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.  
: 백그라운드 스레드, 정적 초기화 과정

상속을 효율적으로 하기 위해 필요한 `훅(Hook)`을 잘 선별하여 protected 메서드로 제공해야 한다.
> [1] 훅(Hook)은 내부 구현이 노출되므로 가능한 적게, 하지만 상속의 이점을 살릴 수 있도록 너무 적지 않게 제공한다.  
[2] 하위 클래스를 만들어 테스트를 하여 훅(Hook)의 개수를 정한다. 이때 하위 클래스는 3개 이상, 이 중 하나 이상은 제3자가 구현하여 테스트한다.
 
상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.
> [1] clone 메서드와 readObject 메서드도 생성자와 비슷한 효과를 내기 때문에 재정의 가능 메서드를 호출해서는 안 된다.  
[2] 재정의가 불가능한 `private, final, static` 메서드만 호출하도록 한다.

### 4. 일반 클래스의 안전한 상속 방법
각각의 재정의 가능 메서드의 본문 코드를 private `도우미 메서드`로 옮기고, 이 도우미 메서드를 호출하도록 수정한다.

## Part 2. 상속의 단점 및 금지 방법

### 1. 상속의 단점
* 내부 구현을 공개하기 때문에 캡슐화를 해친다.
* 상속용으로 설계되거나 문서화되지 않은 경우, 상속으로 인해 오작동이 발생할 수 있다.

### 2. 상속을 금지하는 방법
* 클래스 final 선언
* 모든 생성자 private, package-private 선언 후 public 정적 팩토리 메서드 생성(아이템 17 참고)  
```java
public class StaticFactoryExam {
    private StaticFactoryExam() {
    }

    public static StaticFactoryExam valueOf() {
        return new StaticFactoryExam();
    }
}
```

## Part3. 상속의 대안

### 1. 인터페이스를 구현하는 방식
타입을 정의하여 사용하는 방식으로 계층구조를 형성하지 않으며, 손쉽게 기능을 추가할 수 있다.  
* `List, Map, Set`이 좋은 예시

### 2. 래퍼 클래스 패턴
위임(Delegate)을 통한 기능 구현(아이템 18 참고)
```java
public class WrapperSet<E> {
    private final Set<E> set;
    
    public WrapperSet(Set<E> set) {
        this.set = set;
    }
    
    //... 생략
    public boolean add(E e) {
        return set.add(e);
    }
    public boolean remove(Object o) {
        return set.remove(o);
    }
}
```


## 결론
> 상속용 클래스를 설계하기란 결코 만만치 않다. 클래스 내부에서 스스로를 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야 하며, 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다.
> 그러지 않으면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 있다. 다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다.
> 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 나을 것이다. 상속을 금지하면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.